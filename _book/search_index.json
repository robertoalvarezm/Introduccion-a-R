[["index.html", "Notas de R Chapter 1 Acá empieza", " Notas de R Roberto Álvarez 2022-08-11 Chapter 1 Acá empieza "],["intro.html", "Chapter 2 Introducción a R 2.1 Paquetes o bibliotecas 2.2 Ayuda en R 2.3 Expresiones y asignaciones 2.4 Movimiento entre directorios 2.5 Importante 2.6 Operaciones aritméticas 2.7 Prioridad en las operaciones 2.8 Tipos de datos lógicos o booleanos 2.9 # Vectores en R", " Chapter 2 Introducción a R R es un elenguaje de programación. Además es un entorno integrado para el manejo de datos, el cálculo, la generación de gráficos y análisis estadísticos. Las principales ventajas del uso de R son: Es software libre. Su facilidad para el manejo y almacenamiento de datos. Es un conjunto de operadores para el cálculo de vectores y matrices. Es una colección extensa e integrada de herramientas intermedias para el análisis estadístico de datos. Posee un multitud de facilidades gráficas de altísima calidad Es un lenguaje de programación (muy) poderoso con muchas librerías , bibliotecas más porpiamente dicho, especializadas disponibles. La mejor herramienta para trabajar con datos genómicos, proteomicos, redes, metabolómica, entre varias más. Casi todos podemos aprender por nuestra cuenta a usar excel (pero hay que pagar por la licencia…), sin embargo es más díficil aprender por nuestra cuenta R; y si lo hacemos nos da una ventaja sobre el resto. 2.1 Paquetes o bibliotecas Las funciones especializadas de R se guardan en bibliotecas (packages) que deben ser invocados ANTES de llamar a una función de la biblioteca Una manera de instalar bibliotecas es mediante el repositorio por defecto de R que es CRAN. Navega por CRAN y encuentra algunos paquetes que podrían interesarte. Hay miles y cada día aumentan. Para saber qué paquetes se tienen instalados en tu máquina teclea la función library() library() Para cargar un paquete en particular deben teclear, siempre y cuando ya esté instalado library(nombre_de_paquete) Por ejemplo library(gplots) ## ## Attaching package: &#39;gplots&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## lowess Para visualizar los paquetes ya cargados tecleamos search() ## [1] &quot;.GlobalEnv&quot; &quot;package:gplots&quot; &quot;package:stats&quot; ## [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [10] &quot;package:base&quot; Para visualizar las funciones dentro de un paquete en particular se utiliza ls(2) ## [1] &quot;angleAxis&quot; &quot;balloonplot&quot; &quot;bandplot&quot; &quot;barplot2&quot; ## [5] &quot;bluered&quot; &quot;boxplot2&quot; &quot;ci2d&quot; &quot;col2hex&quot; ## [9] &quot;colorpanel&quot; &quot;greenred&quot; &quot;heatmap.2&quot; &quot;hist2d&quot; ## [13] &quot;lmplot2&quot; &quot;lowess&quot; &quot;ooplot&quot; &quot;overplot&quot; ## [17] &quot;panel.overplot&quot; &quot;plot.venn&quot; &quot;plotCI&quot; &quot;plotLowess&quot; ## [21] &quot;plotmeans&quot; &quot;qqnorm.aov&quot; &quot;redblue&quot; &quot;redgreen&quot; ## [25] &quot;reorder.factor&quot; &quot;residplot&quot; &quot;rich.colors&quot; &quot;sinkplot&quot; ## [29] &quot;smartlegend&quot; &quot;space&quot; &quot;textplot&quot; &quot;venn&quot; ## [33] &quot;wapply&quot; demo(graphics) ## ## ## demo(graphics) ## ---- ~~~~~~~~ ## ## &gt; # Copyright (C) 1997-2009 The R Core Team ## &gt; ## &gt; require(datasets) ## ## &gt; require(grDevices); require(graphics) ## ## &gt; ## Here is some code which illustrates some of the differences between ## &gt; ## R and S graphics capabilities. Note that colors are generally specified ## &gt; ## by a character string name (taken from the X11 rgb.txt file) and that line ## &gt; ## textures are given similarly. The parameter &quot;bg&quot; sets the background ## &gt; ## parameter for the plot and there is also an &quot;fg&quot; parameter which sets ## &gt; ## the foreground color. ## &gt; ## &gt; ## &gt; x &lt;- stats::rnorm(50) ## ## &gt; opar &lt;- par(bg = &quot;white&quot;) ## ## &gt; plot(x, ann = FALSE, type = &quot;n&quot;) ## ## &gt; abline(h = 0, col = gray(.90)) ## ## &gt; lines(x, col = &quot;green4&quot;, lty = &quot;dotted&quot;) ## ## &gt; points(x, bg = &quot;limegreen&quot;, pch = 21) ## ## &gt; title(main = &quot;Simple Use of Color In a Plot&quot;, ## + xlab = &quot;Just a Whisper of a Label&quot;, ## + col.main = &quot;blue&quot;, col.lab = gray(.8), ## + cex.main = 1.2, cex.lab = 1.0, font.main = 4, font.lab = 3) ## ## &gt; ## A little color wheel. This code just plots equally spaced hues in ## &gt; ## a pie chart. If you have a cheap SVGA monitor (like me) you will ## &gt; ## probably find that numerically equispaced does not mean visually ## &gt; ## equispaced. On my display at home, these colors tend to cluster at ## &gt; ## the RGB primaries. On the other hand on the SGI Indy at work the ## &gt; ## effect is near perfect. ## &gt; ## &gt; par(bg = &quot;gray&quot;) ## ## &gt; pie(rep(1,24), col = rainbow(24), radius = 0.9) ## ## &gt; title(main = &quot;A Sample Color Wheel&quot;, cex.main = 1.4, font.main = 3) ## ## &gt; title(xlab = &quot;(Use this as a test of monitor linearity)&quot;, ## + cex.lab = 0.8, font.lab = 3) ## ## &gt; ## We have already confessed to having these. This is just showing off X11 ## &gt; ## color names (and the example (from the postscript manual) is pretty &quot;cute&quot;. ## &gt; ## &gt; pie.sales &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12) ## ## &gt; names(pie.sales) &lt;- c(&quot;Blueberry&quot;, &quot;Cherry&quot;, ## + &quot;Apple&quot;, &quot;Boston Cream&quot;, &quot;Other&quot;, &quot;Vanilla Cream&quot;) ## ## &gt; pie(pie.sales, ## + col = c(&quot;purple&quot;,&quot;violetred1&quot;,&quot;green3&quot;,&quot;cornsilk&quot;,&quot;cyan&quot;,&quot;white&quot;)) ## ## &gt; title(main = &quot;January Pie Sales&quot;, cex.main = 1.8, font.main = 1) ## ## &gt; title(xlab = &quot;(Don&#39;t try this at home kids)&quot;, cex.lab = 0.8, font.lab = 3) ## ## &gt; ## Boxplots: I couldn&#39;t resist the capability for filling the &quot;box&quot;. ## &gt; ## The use of color seems like a useful addition, it focuses attention ## &gt; ## on the central bulk of the data. ## &gt; ## &gt; par(bg=&quot;cornsilk&quot;) ## ## &gt; n &lt;- 10 ## ## &gt; g &lt;- gl(n, 100, n*100) ## ## &gt; x &lt;- rnorm(n*100) + sqrt(as.numeric(g)) ## ## &gt; boxplot(split(x,g), col=&quot;lavender&quot;, notch=TRUE) ## ## &gt; title(main=&quot;Notched Boxplots&quot;, xlab=&quot;Group&quot;, font.main=4, font.lab=1) ## ## &gt; ## An example showing how to fill between curves. ## &gt; ## &gt; par(bg=&quot;white&quot;) ## ## &gt; n &lt;- 100 ## ## &gt; x &lt;- c(0,cumsum(rnorm(n))) ## ## &gt; y &lt;- c(0,cumsum(rnorm(n))) ## ## &gt; xx &lt;- c(0:n, n:0) ## ## &gt; yy &lt;- c(x, rev(y)) ## ## &gt; plot(xx, yy, type=&quot;n&quot;, xlab=&quot;Time&quot;, ylab=&quot;Distance&quot;) ## ## &gt; polygon(xx, yy, col=&quot;gray&quot;) ## ## &gt; title(&quot;Distance Between Brownian Motions&quot;) ## ## &gt; ## Colored plot margins, axis labels and titles. You do need to be ## &gt; ## careful with these kinds of effects. It&#39;s easy to go completely ## &gt; ## over the top and you can end up with your lunch all over the keyboard. ## &gt; ## On the other hand, my market research clients love it. ## &gt; ## &gt; x &lt;- c(0.00, 0.40, 0.86, 0.85, 0.69, 0.48, 0.54, 1.09, 1.11, 1.73, 2.05, 2.02) ## ## &gt; par(bg=&quot;lightgray&quot;) ## ## &gt; plot(x, type=&quot;n&quot;, axes=FALSE, ann=FALSE) ## ## &gt; usr &lt;- par(&quot;usr&quot;) ## ## &gt; rect(usr[1], usr[3], usr[2], usr[4], col=&quot;cornsilk&quot;, border=&quot;black&quot;) ## ## &gt; lines(x, col=&quot;blue&quot;) ## ## &gt; points(x, pch=21, bg=&quot;lightcyan&quot;, cex=1.25) ## ## &gt; axis(2, col.axis=&quot;blue&quot;, las=1) ## ## &gt; axis(1, at=1:12, lab=month.abb, col.axis=&quot;blue&quot;) ## ## &gt; box() ## ## &gt; title(main= &quot;The Level of Interest in R&quot;, font.main=4, col.main=&quot;red&quot;) ## ## &gt; title(xlab= &quot;1996&quot;, col.lab=&quot;red&quot;) ## ## &gt; ## A filled histogram, showing how to change the font used for the ## &gt; ## main title without changing the other annotation. ## &gt; ## &gt; par(bg=&quot;cornsilk&quot;) ## ## &gt; x &lt;- rnorm(1000) ## ## &gt; hist(x, xlim=range(-4, 4, x), col=&quot;lavender&quot;, main=&quot;&quot;) ## ## &gt; title(main=&quot;1000 Normal Random Variates&quot;, font.main=3) ## ## &gt; ## A scatterplot matrix ## &gt; ## The good old Iris data (yet again) ## &gt; ## &gt; pairs(iris[1:4], main=&quot;Edgar Anderson&#39;s Iris Data&quot;, font.main=4, pch=19) ## ## &gt; pairs(iris[1:4], main=&quot;Edgar Anderson&#39;s Iris Data&quot;, pch=21, ## + bg = c(&quot;red&quot;, &quot;green3&quot;, &quot;blue&quot;)[unclass(iris$Species)]) ## ## &gt; ## Contour plotting ## &gt; ## This produces a topographic map of one of Auckland&#39;s many volcanic &quot;peaks&quot;. ## &gt; ## &gt; x &lt;- 10*1:nrow(volcano) ## ## &gt; y &lt;- 10*1:ncol(volcano) ## ## &gt; lev &lt;- pretty(range(volcano), 10) ## ## &gt; par(bg = &quot;lightcyan&quot;) ## ## &gt; pin &lt;- par(&quot;pin&quot;) ## ## &gt; xdelta &lt;- diff(range(x)) ## ## &gt; ydelta &lt;- diff(range(y)) ## ## &gt; xscale &lt;- pin[1]/xdelta ## ## &gt; yscale &lt;- pin[2]/ydelta ## ## &gt; scale &lt;- min(xscale, yscale) ## ## &gt; xadd &lt;- 0.5*(pin[1]/scale - xdelta) ## ## &gt; yadd &lt;- 0.5*(pin[2]/scale - ydelta) ## ## &gt; plot(numeric(0), numeric(0), ## + xlim = range(x)+c(-1,1)*xadd, ylim = range(y)+c(-1,1)*yadd, ## + type = &quot;n&quot;, ann = FALSE) ## ## &gt; usr &lt;- par(&quot;usr&quot;) ## ## &gt; rect(usr[1], usr[3], usr[2], usr[4], col=&quot;green3&quot;) ## ## &gt; contour(x, y, volcano, levels = lev, col=&quot;yellow&quot;, lty=&quot;solid&quot;, add=TRUE) ## ## &gt; box() ## ## &gt; title(&quot;A Topographic Map of Maunga Whau&quot;, font= 4) ## ## &gt; title(xlab = &quot;Meters North&quot;, ylab = &quot;Meters West&quot;, font= 3) ## ## &gt; mtext(&quot;10 Meter Contour Spacing&quot;, side=3, line=0.35, outer=FALSE, ## + at = mean(par(&quot;usr&quot;)[1:2]), cex=0.7, font=3) ## ## &gt; ## Conditioning plots ## &gt; ## &gt; par(bg=&quot;cornsilk&quot;) ## ## &gt; coplot(lat ~ long | depth, data = quakes, pch = 21, bg = &quot;green3&quot;) ## ## &gt; par(opar) 2.2 Ayuda en R help(nombre_comando) o ?nombre_comando help(solve) ?solve son equivalentes para buscar ayuda sobre el comando solve Para buscar ayuda de funciones o palabra reservadas se utilizan comillas help(&quot;for&quot;) Para abrir la ayuda genral en un navegador (sólo si tenemos la ayuda en HTML instalada y tenemos conexión a la red) se utiliza help.start() ## starting httpd help server ... done ## If the browser launched by &#39;/usr/bin/open&#39; is already running, it is ## *not* restarted, and you must switch to its window. ## Otherwise, be patient ... help.search(&quot;clustering&quot;) Si queremos ver ejemplos del uso de los comandos usamos la función ejemplo example(&quot;hclust&quot;) ## ## hclust&gt; require(graphics) ## ## hclust&gt; ### Example 1: Violent crime rates by US state ## hclust&gt; ## hclust&gt; hc &lt;- hclust(dist(USArrests), &quot;ave&quot;) ## ## hclust&gt; plot(hc) ## ## hclust&gt; plot(hc, hang = -1) ## ## hclust&gt; ## Do the same with centroid clustering and *squared* Euclidean distance, ## hclust&gt; ## cut the tree into ten clusters and reconstruct the upper part of the ## hclust&gt; ## tree from the cluster centers. ## hclust&gt; hc &lt;- hclust(dist(USArrests)^2, &quot;cen&quot;) ## ## hclust&gt; memb &lt;- cutree(hc, k = 10) ## ## hclust&gt; cent &lt;- NULL ## ## hclust&gt; for(k in 1:10){ ## hclust+ cent &lt;- rbind(cent, colMeans(USArrests[memb == k, , drop = FALSE])) ## hclust+ } ## ## hclust&gt; hc1 &lt;- hclust(dist(cent)^2, method = &quot;cen&quot;, members = table(memb)) ## ## hclust&gt; opar &lt;- par(mfrow = c(1, 2)) ## ## hclust&gt; plot(hc, labels = FALSE, hang = -1, main = &quot;Original Tree&quot;) ## ## hclust&gt; plot(hc1, labels = FALSE, hang = -1, main = &quot;Re-start from 10 clusters&quot;) ## ## hclust&gt; par(opar) ## ## hclust&gt; ### Example 2: Straight-line distances among 10 US cities ## hclust&gt; ## Compare the results of algorithms &quot;ward.D&quot; and &quot;ward.D2&quot; ## hclust&gt; ## hclust&gt; mds2 &lt;- -cmdscale(UScitiesD) ## ## hclust&gt; plot(mds2, type=&quot;n&quot;, axes=FALSE, ann=FALSE) ## ## hclust&gt; text(mds2, labels=rownames(mds2), xpd = NA) ## ## hclust&gt; hcity.D &lt;- hclust(UScitiesD, &quot;ward.D&quot;) # &quot;wrong&quot; ## ## hclust&gt; hcity.D2 &lt;- hclust(UScitiesD, &quot;ward.D2&quot;) ## ## hclust&gt; opar &lt;- par(mfrow = c(1, 2)) ## ## hclust&gt; plot(hcity.D, hang=-1) ## ## hclust&gt; plot(hcity.D2, hang=-1) ## ## hclust&gt; par(opar) Todo lo anterior requiere que conzocamos el nombre correcto del comando, pero ¿qué pasa si no lo sabemos? Podemos utilizar el comando apropos() para encontrar todo lo relacionado con algún término apropos(&quot;solve&quot;) ## [1] &quot;backsolve&quot; &quot;forwardsolve&quot; &quot;qr.solve&quot; &quot;solve&quot; ## [5] &quot;solve.default&quot; &quot;solve.qr&quot; 2.2.1 Sesiones interactivas En R también podmeos generar elementos interactivos con la bilioteca shiny ## ## Listening on http://127.0.0.1:5575 2.3 Expresiones y asignaciones Hay dos tipos de resultados en R: expresiones y asignaciones. Las primeras sólo se muestran a la salida estándar y NO se guardan en una variable; las segundas, se asignan y guardan en una variable Expresión: rnorm(10) ## [1] 0.4607957 0.7228773 -0.2240450 0.5244111 1.2770707 1.2844097 ## [7] 1.7656964 -0.8556974 -0.1464486 -0.5650853 Asignación x &lt;- rnorm(10) x ## [1] 1.9890878 -0.8827740 0.2670051 0.3350804 0.8514697 -0.1043465 ## [7] 1.4598762 -0.8251746 -0.8172434 0.6365634 Operado de asignación. Evitar el uso del igual R distingue entre mayúsculas y minúsculas, así las siguientes variables contienen valores distintos a &lt;- 3 A &lt;- 6 Los comandos pueden separarse por ; o - mejor opción- por un salto de línea a &lt;- 3; b &lt;-5 también pueden definirse asignaciones en más de una línea a &lt;- pi + 12 2.4 Movimiento entre directorios Para saber en qué directorio estamos tecleamos getwd() ## [1] &quot;/Users/robertoalvarez/Dropbox/UAQ/Bioinformatica/Introduccion-a-R.github.io&quot; Para cambiar de directorio utilizamos setwd(\"direccion_a_la_que_quieres_ir\") setwd(&quot;~&quot;) También podemos usar los comandos de bash dentro de R, utilizando la función system() system(&quot;ls -la&quot;) system(&quot;pwd&quot;) 2.5 Importante Como regla general todos los nombres van entre comillas: nombre de carpetas, archivos, de columnas, de renglones,etc. 2.6 Operaciones aritméticas Se puede sumar, restar, multiplicar,dividir, “exponenciar” y calcular la raíz cuadrada. Los operadores son, respectivamente: +,-,*, /,** o ^, sqrt() a + b ## [1] 20.14159 a - b ## [1] 10.14159 a * b ## [1] 75.70796 a ** b ## [1] 795898.7 a ^ b ## [1] 795898.7 sqrt(a) ## [1] 3.89122 2.7 Prioridad en las operaciones Las operaciones se efectuan en el siguiente orden: izquierda a derecha sqrt() y ** , ^ “*” y / “+” y - &lt;- Este orden se altera si se presenta un paréntesis. En ese caso la operación dentro del paréntesis es la que se realiza primero. Ejemplos 4 + 2 *3 = 4 + 6 = 10 4-15/3 +3^2 +sqrt(9)= 4-15/3 + 9 +3 = 4-5+12=13 4-(3+7)^2 + (2+3)/5=4-100+5/5=-95 2.7.1 Ejercicios Resuelve en un pedazo de papel primero para saber cuál sería el resultado de las siguientes operaciones aritméticas. Después comprueba tu resultado tecleandolas en R 1 + 2*3 +3 +15/3 4-15/3 +3^2 +3*sqrt(81) 40-(4+3)^2 + (10-5)/3 2.8 Tipos de datos lógicos o booleanos Estos tipos de datos sólo contienen información TRUE o FALSE. Sirven para evaluar expresiones de =, &lt;, &gt; y pueden utilizarse para obtener los elementos de un vector que cumplan con la característica deseada. 1 &lt; 5 ## [1] TRUE 10 == 0 # Es igual a ## [1] FALSE 10 != 0 # NO es igual a ## [1] TRUE 10 &lt;= 0 #Menor o igual ## [1] FALSE Dentro de R un valor lógico TRUE equivale a 1 y FALSE equivale a 0, por lo tanto para contar cuántos TRUEs hay podemos hacer una suma: Ejercicio utiliza una sola líndea de R para averiguar si el logaritmo base de 10 de 20 es menor que la raiz cuadrada de 4. 2.8.1 Caracter Son strings de texto. Se distingue porque los elementos van entre comillas (cada uno). Puede ser desde un sólo caracter hasta oraciones completas. Puede parecer que contienen números, pero las comillaa indican que serán tratados como texto. Podemos subsetearlos por su índice o buscando literalmente el texto. x&lt;- &quot;La candente mañana de febrero en que Beatriz Viterbo murió, después de una imperiosa agonía que no se rebajó un solo instante ni al sentimentalismo ni al miedo&quot; 2.8.2 Enteros y números (numeric) R por default representa los números como numeric, NO integer. Estos tipos son dos formas diferentes en las cuales las computadoras pueden guardar los números y hacer operaciones matemáticas con ellos. Por lo común esto no importa, pero puede ser relevante para algunas funciones de Bioconductor, por ejemplo ya que el tamaño máximo de un integer en R es ligeramente más chico que el tamaño del genoma humano. ¿Cómo revisar si un objeto es numeric o entero? x &lt;- 1 class(x) ## [1] &quot;numeric&quot; x &lt;- 1:3 class(x) ## [1] &quot;integer&quot; 2.9 # Vectores en R En R puedes guardar muchos elementos del mismo tipo en un sólo objeto mediante vectores. Un vector es una colección de datos del mismo tipo. Siempre del mismo tipo. No es posible mezclarlos. "],["vectores.html", "Chapter 3 Vectores 3.1 Definición 3.2 Uso de la función combine c() y el operador : 3.3 Acceder a elementos de un vector 3.4 Agregar y quitar elementos de un vector 3.5 Repetición de elementos de un vector con rep() 3.6 Uso de funciones any() y all() 3.7 Operaciones con vectores 3.8 Gráficos con vectores 3.9 Vectores con nombre 3.10 ¿Cómo lidiar con las NAs ? 3.11 Filtrado de elementos de un vector 3.12 ¿Cómo podemos ver si dos vectores son iguales?", " Chapter 3 Vectores 3.1 Definición Para definir un vector se utiliza la función c(), que siginfica combine x &lt;- c(1,2,6,90,76.7) 3.1.1 Longitud de un vector Para obtener la longitud de un vector, es decir el número de elementos que tiene se utiliza la función length() length(x) ## [1] 5 Como siempre, para mostrar el contenido de una variable sólo es necesario poner la variable y presionar enter en la sesión interactiva, si se está en un script es necesario usar la función print() 3.2 Uso de la función combine c() y el operador : Un vector se puede definir de forma extensiva, es decir poniendo explícitamente todos los valores del vector. y&lt;-c(&quot;esto&quot;,&quot;es&quot;,&quot;un&quot;,&quot;vector&quot;) z&lt;-c(1,10,100,1000) Esto es muy poco eficiente a menos que los vectores sean muy pequeños por lo que existen funciones para generar algunos casos particulares. Por ejemplo, si queremos tener un vector que tenga los primeros 100 números enteros podemos definirlo de la siguiente manera con el uso del operador : : x&lt;-1:100; x ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ## [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ## [91] 91 92 93 94 95 96 97 98 99 100 También se puede usar de forma equivalente la función seq() que significa sequence. seq() es una generalización del operador :, x&lt;-seq(1,100) x ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ## [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ## [91] 91 92 93 94 95 96 97 98 99 100 con ella podemos generar secuencias numéricas de distintas clase y espaciadas por diferentes rangos. Por ejemplo si queremos tener una secuencia de -12 a 30 en pasos de 3, es decir -12, -9,-6,…, 27,30 Teclearíamos x&lt;-seq(from=-12,to=30,by=3) x ## [1] -12 -9 -6 -3 0 3 6 9 12 15 18 21 24 27 30 Podemos omitir los nombres from, to,by si usamos el mismo orden, si queremos intercambiarlo debemos necesariamente ponerlos y&lt;-seq(0,1,0.1) y ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 z&lt;-seq(by=0.1, to =1, from=0.5) z ## [1] 0.5 0.6 0.7 0.8 0.9 1.0 3.3 Acceder a elementos de un vector 3.3.1 Elementos consecutivos de un vector Para acceder a elemetnos de un objeto con índices en R debemos usar los corchetes [] para indicarle que queremos seleccionar esos objetos x&lt;-c(&quot;Muchos&quot;, &quot;años&quot; ,&quot;después&quot; ,&quot;,&quot;, &quot;frente&quot;, &quot;al&quot; ,&quot;pelotón&quot;) x[1:4] ## [1] &quot;Muchos&quot; &quot;años&quot; &quot;después&quot; &quot;,&quot; ` x&lt;-c(1,2,3,5,8,13,21) x[3:6] ## [1] 3 5 8 13 3.3.2 Elementos no consecutivos de un vector Para seleccionar elementos no consecutivos definimos un nuevo vector (con la función c() ) de índices que seleccionará los elementos que quieres x&lt;-c(&quot;Muchos&quot;, &quot;años&quot; ,&quot;después&quot; ,&quot;,&quot;, &quot;frente&quot;, &quot;al&quot; ,&quot;pelotón&quot;) x[c(1,3,5,7)] ## [1] &quot;Muchos&quot; &quot;después&quot; &quot;frente&quot; &quot;pelotón&quot; No es necesario que estén en orden x&lt;-c(1,2,3,5,8,13,21) x[c(2, 7, 4)] ## [1] 2 21 5 3.3.3 Excluir elementos de un vector Para seleccionar algunos elementos excepto un conjunto de ellos usamos el signo menos - x&lt;-c(1,2,3,5,8,13,21) x[-2] ## [1] 1 3 5 8 13 21 # Todos menos el segundo elemento x[-c(2, 7, 4)] # Todos menos el segundo , séptimo y cuarto elemento ## [1] 1 3 8 13 x[-length(x)] # ¿Esto qué hace? ## [1] 1 2 3 5 8 13 Este comando no elimina elementos de un vector sólo los selecciona x&lt;-c(1,2,3,5,8,13,21) x[-6] ## [1] 1 2 3 5 8 21 x # Estoy intacto ## [1] 1 2 3 5 8 13 21 3.4 Agregar y quitar elementos de un vector x &lt;- c(88,5,12,13) x &lt;- c(x[1:3],168,x[4]) x ## [1] 88 5 12 168 13 Podemos, incluso, definir un vector vacío y luego “llenarlo” x&lt;-c() x # Soy un vector vacío :( ## NULL x[1]&lt;- 2 x[2:5]&lt;-c(56,78,90,12) x # Ahora ya no :) ## [1] 2 56 78 90 12 3.5 Repetición de elementos de un vector con rep() La función rep() que viene del inglés repeat nos permite repetir elementos en un vector dado. Por ejemplo, rep(x,n veces) x&lt;-rep(3,5) x ## [1] 3 3 3 3 3 y&lt;-rep(c(1,2,3,5),3) y ## [1] 1 2 3 5 1 2 3 5 1 2 3 5 primos&lt;-c(1,2,3,5,7,11) z&lt;-rep(primos,4) z ## [1] 1 2 3 5 7 11 1 2 3 5 7 11 1 2 3 5 7 11 1 2 3 5 7 11 También podemos usar la opción each para indicar la frecuencia de repetición x&lt;-c(1,2,3,4) y&lt;-rep(x,each=2) y ## [1] 1 1 2 2 3 3 4 4 3.6 Uso de funciones any() y all() Las funciones any() y all() determinan si alguno o todos los elementos de un vector cumplen cierta condición respectivamente. La respuesta siempre será un valor booleano es decir: TRUE o FALSE x&lt;- 1:15 any(x &gt; 7.5) ## [1] TRUE any(x &gt; 19.76) ## [1] FALSE any(x &gt;= 15) ## [1] TRUE all(x&gt; sqrt(100)) ## [1] FALSE all(x&gt;0) ## [1] TRUE 3.7 Operaciones con vectores Al igual que en álgebra podemos definir varias operaciones que nos dejan siempre otro vector: Suma (resta) de vectores Producto de vectores (término a término) Producto de un escalar por un vector x&lt;-c(1,2,3) y&lt;-c(4,5,6) x + y ## [1] 5 7 9 x-y ## [1] -3 -3 -3 x*x ## [1] 1 4 9 y*y ## [1] 16 25 36 x*y ## [1] 4 10 18 3*x #Multiplicación por escalar: término a término ## [1] 3 6 9 sqrt(2)*y # Sí, por cualquier escalar! ## [1] 5.656854 7.071068 8.485281 3*x + sqrt(2)*y # Operaciones más complejas ## [1] 8.656854 13.071068 17.485281 También podemos aplicar funciones para calcular con una sola instrucción varias operaciones útiles, por ejemplo min(), max(), range() , sum(), mean(), median(), sd(),quantile(),unique(),sort() Si tienes duda de qué hace alguna de ellas busca en la ayuda x&lt;-rnorm(1000) min(x) ## [1] -3.37226 max(x) ## [1] 3.240827 range(x) ## [1] -3.372260 3.240827 sum(x) ## [1] 8.015291 mean(x) ## [1] 0.008015291 median(x) ## [1] -0.006532202 sd(x) ## [1] 1.020053 quantile(x) ## 0% 25% 50% 75% 100% ## -3.372259941 -0.711552846 -0.006532202 0.705772989 3.240827266 Para unique() y sort() conviene tener elementos discretos más que continuos x&lt;- c(rep(3,5),1:15,rep(c(1,2,3),5)) unique(x) ## [1] 3 1 2 4 5 6 7 8 9 10 11 12 13 14 15 x&lt;-sample(10,10) x ## [1] 5 7 3 2 9 1 10 4 8 6 sort(x) ## [1] 1 2 3 4 5 6 7 8 9 10 3.8 Gráficos con vectores Podemos graficar los vectores de manera inmediata en R x&lt;- rnorm(10000) hist(x,col=&quot;tomato2&quot;) plot(x,col=&quot;salmon&quot;) boxplot(x,col=&quot;wheat&quot;) 3.9 Vectores con nombre Definimos un vector llamado edades edades&lt;-c(35,35,70,17,14) edades ## [1] 35 35 70 17 14 Podemos definir un vector del mismo tamaño que edades llamado nombres nombres &lt;-c(&quot;Jerry&quot;,&quot;Beth&quot;,&quot;Rick&quot;, &quot;Summer&quot;,&quot;Morty&quot;) nombres ## [1] &quot;Jerry&quot; &quot;Beth&quot; &quot;Rick&quot; &quot;Summer&quot; &quot;Morty&quot; Una de las cracterísticas de R es que podemos asignarles nombres a los vectores, para ello usamos la función names() names(edades)&lt;-nombres Con ello ahora el vector edades tiene una nueva característica: edades ## Jerry Beth Rick Summer Morty ## 35 35 70 17 14 Podemos selecccionar de la manera usual, por ejemplo, si quiero ver cuál es la edad de Rick, debo seleccionar el 3 elemento edades[3] ## Rick ## 70 Esto es muy poco eficiente y propenso al error sobre todo con vectores muy grandes. Por ello podemos usar los nombres de los vectores edades[&quot;Rick&quot;] ## Rick ## 70 Recuerda que los nombres S-I-E-M-P-R-E van entre comillas edades[c(&quot;Rick&quot;,&quot;Morty&quot;)] ## Rick Morty ## 70 14 Ejercicios: ¿Cuál es el promedio de las edades, sin contar el de Beth? Quiten a Morty del vector, ordénenlo y guárdenlo como un nuevo objeto. ¿Hay alguna edad que sea mayor de 75? ¿Menor de 12? ¿Entre 12 y 20? 3.9.1 Tamaños de genomas Ahora veamos un ejemplo más “biológico” genomeSizeM_BP&lt;-c(3234.83,2716.97,143.73,0.014281,12.1) Por ejemplo si quisierámos ver el tamño en bp simplemente multiplicamos por el valor del prefijo Mega = 1 millón genomeSizeM_BP*1e6 ## [1] 3234830000 2716970000 143730000 14281 12100000 organismo&lt;-c(&quot;Human&quot;,&quot;Mouse&quot;,&quot;Fruit Fly&quot;,&quot;Roundworm&quot;,&quot;Yeast&quot;) names(genomeSizeM_BP) &lt;- organismo genomeSizeM_BP ## Human Mouse Fruit Fly Roundworm Yeast ## 3234.830000 2716.970000 143.730000 0.014281 12.100000 Se pueden seleccionar elementos de un vector utilizando corchetes genomeSizeM_BP[1] ## Human ## 3234.83 Para obtener elementos consecutivos genomeSizeM_BP[1:4] ## Human Mouse Fruit Fly Roundworm ## 3234.830000 2716.970000 143.730000 0.014281 Para obtener elementos NO consecutivos genomeSizeM_BP[c(1,2,5)] ## Human Mouse Yeast ## 3234.83 2716.97 12.10 Para selecciona (no eliminar, ni quitar) elementos excepto algunos genomeSizeM_BP[-c(1,3,5)] ## Mouse Roundworm ## 2716.970000 0.014281 Para referirnos a los elementos por su nombre genomeSizeM_BP[c(&quot;Yeast&quot;,&quot;Human&quot;)] ## Yeast Human ## 12.10 3234.83 Además de algunas operaciones aritméticas, se pueden calcular la media, máximo, mediana, mínimo, suma y longitud de los vectores Ejercicio Generar un vector de las edades de 10 de tus compañeros Asignales nombre. Encuentra el mínimo,máximo, media, mediana, la desviación estándar, la longitud del vector y selecciona sólo los elementos impares. Elimina el máximo y el mínimo y con el vector resultante realiza un histograma. Crea un vector de caracteres con diez nombres de especies y asocialo con su número de acceso de NCBI para su genoma en nucleótidos. 3.10 ¿Cómo lidiar con las NAs ? Es (muy) freceunte que en bases de datos se tengan valores NA, es decir medidas que no pudieron realizarse, medidas perdidas, etc. Para ello se utiliza NA. R trata de manera especial a las NAs x &lt;- c(88,NA,12,168,13) Existe una fución para determinar si un elemento es o no una NA. La función es is.na() x &lt;- c(88,NA,12,168,13) is.na(x) ## [1] FALSE TRUE FALSE FALSE FALSE Si queremos calcular ciertas funciones numéricas R no sabrá qué hacer x &lt;- c(88,NA,12,168,13) mean(x) ## [1] NA Sin emabrgo, podemos decirle a R que las omita, indicando como argumento de la función mean() na.rm=TRUE que significa na remove x &lt;- c(88,NA,12,168,13) mean(x,na.rm=TRUE) ## [1] 70.25 ¿Qué otras funciones tienen esta opción? 3.11 Filtrado de elementos de un vector Podemos generar vectores de que sean subconjuntos de vectores más grandes que cumplan cierta(s) condición(es) un_vector&lt;-c(1,2,3,5,7,11,13,17,19) otro_vector &lt;- un_vector[un_vector*un_vector &gt; 10] # Leeme de adentro hacia afuera otro_vector ## [1] 5 7 11 13 17 19 Veamos paso a paso qué es lo que hace este proceso un_vector ## [1] 1 2 3 5 7 11 13 17 19 un_vector*un_vector &gt; 10 # Mira, de adentro hacia afuera ## [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE indices&lt;-un_vector*un_vector &gt; 10 un_vector[indices] ## [1] 5 7 11 13 17 19 un_vector[c(FALSE,FALSE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE)] ## [1] 5 7 11 13 17 19 la representación interna de los valores booleanos FALSE y TRUEson 0 y 1 respectivamente un_vector[c(rep(0,3),rep(1,1))] ## [1] 1 3.11.1 Filtrado con subset() Podemos usar la función subset()para hacer lo mismo que en el caso anterior excepto que omite los NA un_vector&lt;-c(1,2,3,5,7,11,13,17,19) otro_vector &lt;- subset(un_vector,un_vector*un_vector &gt; 10) otro_vector ## [1] 5 7 11 13 17 19 Qué pasa si tenemos NAs. Si usamos el método anterior obtendríamos un_vector&lt;-c(1,2,3,5,7,11,NA,13,17,NA,19) otro_vector &lt;- un_vector[un_vector*un_vector &gt; 10] # Leeme de adentro hacia afuera otro_vector # Aquí salen las NAs ## [1] 5 7 11 NA 13 17 NA 19 En cambio con subset() un_vector&lt;-c(1,2,3,5,7,11,NA, 13,17,NA, 19) otro_vector &lt;- subset(un_vector,un_vector*un_vector &gt; 10) otro_vector # Aquí ya no aparecen las NAs ## [1] 5 7 11 13 17 19 3.11.2 La función de selección which() La función which() nos regresa los índices es decir nos dicen quiénes cumplen cierta condición z &lt;- c(5,2,-3,8) which(z*z &gt; 8) ## [1] 1 3 4 Acá nos dicen quiénes z[which(z*z &gt; 8)] ## [1] 5 -3 8 3.12 ¿Cómo podemos ver si dos vectores son iguales? Dos vectores son iguales si elemento a elemento son idénticos. Por lo tanto deben de ser del mismo tamaño. Para probar si dos elementos son iguales se utiliza el operador de comparación == son dos signos iguales juntos, sin espcaio. No confundir con el operador = que se puede usar como operador de asiganción (aunque no es recomendable su uso. De hecho está prohibido en este curso) x&lt;-c(1,4,9,16,25) y&lt;-1:5 y&lt;-y*y x==y ## [1] TRUE TRUE TRUE TRUE TRUE ¿Qué pasaría si me confundo y escribo el operador de igualdad en lugar del de comparación? y &lt;-5:9 y ## [1] 5 6 7 8 9 x=y x ## [1] 5 6 7 8 9 y ## [1] 5 6 7 8 9 Para vectores grandes puedo usar la función all() que ya vimos arriba x &lt;- seq(1,10000,1) y &lt;- seq(1,10000,1) all(x==y) ## [1] TRUE ¿Cómo podríamos corrobar que son iguales usando any? También podríamos utilizar que TRUE es 1 y que FALSE es 0 ¿Por qué este código nos dice que sí son iguales? sum(x==y) ## [1] 10000 3.12.1 Factor Los factores son un tipo de vector que puede tomar un número “limitado” de valores, que normalmente se utilizan como variables categóricas. Por ejemplo: macho/hembra. Es útil tenener este tipo de objeto porque varios modelos estadísticos que se pueden correr en R los utilizan. A los valores que pueden tomar los elementos del factor se les conoce como levels. x&lt;- c(1,2,2,3,1,2,3,3,1,2,3,3,1) x ## [1] 1 2 2 3 1 2 3 3 1 2 3 3 1 as.factor(x) ## [1] 1 2 2 3 1 2 3 3 1 2 3 3 1 ## Levels: 1 2 3 x&lt;-as.factor(x) x ## [1] 1 2 2 3 1 2 3 3 1 2 3 3 1 ## Levels: 1 2 3 Los factores son una manera computacionalmente eficiente de almacenar caracteres, pues cada valor único (level) se guarda solo una vez y a los datos se les asigna un valor entero. meses = c(&quot;March&quot;,&quot;April&quot;,&quot;January&quot;,&quot;November&quot;,&quot;January&quot;, &quot;September&quot;,&quot;October&quot;,&quot;September&quot;,&quot;November&quot;,&quot;August&quot;, &quot;January&quot;,&quot;November&quot;,&quot;November&quot;,&quot;February&quot;,&quot;May&quot;,&quot;August&quot;, &quot;July&quot;,&quot;December&quot;,&quot;August&quot;,&quot;August&quot;,&quot;September&quot;,&quot;November&quot;, &quot;February&quot;,&quot;April&quot;) meses ## [1] &quot;March&quot; &quot;April&quot; &quot;January&quot; &quot;November&quot; &quot;January&quot; &quot;September&quot; ## [7] &quot;October&quot; &quot;September&quot; &quot;November&quot; &quot;August&quot; &quot;January&quot; &quot;November&quot; ## [13] &quot;November&quot; &quot;February&quot; &quot;May&quot; &quot;August&quot; &quot;July&quot; &quot;December&quot; ## [19] &quot;August&quot; &quot;August&quot; &quot;September&quot; &quot;November&quot; &quot;February&quot; &quot;April&quot; meses&lt;-as.factor(meses) meses ## [1] March April January November January September October ## [8] September November August January November November February ## [15] May August July December August August September ## [22] November February April ## 11 Levels: April August December February January July March May ... September El que existan los levels permite realizar ciertas operaciones y manipular el contenido del factor. table(meses) ## meses ## April August December February January July March May ## 2 4 1 2 3 1 1 1 ## November October September ## 5 1 3 levels(meses) ## [1] &quot;April&quot; &quot;August&quot; &quot;December&quot; &quot;February&quot; &quot;January&quot; &quot;July&quot; ## [7] &quot;March&quot; &quot;May&quot; &quot;November&quot; &quot;October&quot; &quot;September&quot; levels(meses)[1] ## [1] &quot;April&quot; levels(meses)[1]&lt;-&quot;Abril&quot; levels(meses) ## [1] &quot;Abril&quot; &quot;August&quot; &quot;December&quot; &quot;February&quot; &quot;January&quot; &quot;July&quot; ## [7] &quot;March&quot; &quot;May&quot; &quot;November&quot; &quot;October&quot; &quot;September&quot; meses ## [1] March Abril January November January September October ## [8] September November August January November November February ## [15] May August July December August August September ## [22] November February Abril ## 11 Levels: Abril August December February January July March May ... September Ejercicio Lee la ayuda de as.factor para determinar cómo crear un factor “ordenado” Crea un vector con los meses en los que todas las alumnas del grupo cumplen años. Aprovecha los levels para generar un objeto que guarde el número de estudiantes que cumplena ño cada mes. Ejercicio Genera un vector con el nombre de 10 virus Asocia esos nombres con su número de acceso en NCBI Genera otro vector que contega los tamaños en pb y los nombres Determina cuáles son mayores de 300 bp Asocia un subconjunto de vectores que sean mayores (menores a 300 bp) y mayores (mayores a 300 bp) Haz un histograma con los tamaños de todos Dibuja un boxplot con los tamaños de todos.Pon en el eje los nombres de todos. "],["matrices.html", "Chapter 4 Matrices 4.1 Creación de matrices 4.2 Dimensiones de un matriz 4.3 Operaciones con matrices 4.4 Seleccionar elementos de matrices 4.5 Nombres a renglones y columnas", " Chapter 4 Matrices Una matriz es un arreglo rectangular de datos del mismo tipo. No. No se pueden mezclar. 4.1 Creación de matrices Para crear una matriz podemos usar la función matrix(). Dicha función requiere de, al menos un vector e indicar al menos una dimensión. y &lt;- matrix(c(1,5,8,-4),nrow=2,ncol=2) y ## [,1] [,2] ## [1,] 1 8 ## [2,] 5 -4 Se el indica el numero de renglones y el número de columnas como opción usando nrow y ncol respectivamente. La matriz se llena por renglones hasta completarse z&lt;-matrix(c(TRUE, FALSE,rep(c(TRUE, FALSE),3)),nrow=4) z ## [,1] [,2] ## [1,] TRUE TRUE ## [2,] FALSE FALSE ## [3,] TRUE TRUE ## [4,] FALSE FALSE ¿Por qué sólo es necesario indicar una dimensión? Podemos decirle a R que cambie el orden con el que llena la matriz, es decir en lugar de que lo haga por columnas, lo haga por renglones m &lt;- matrix(c(1,2,3,4,5,6),nrow=2,byrow=TRUE) m ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 4.2 Dimensiones de un matriz La dimensión de una matriz es el número de renglones y de columnas respectivamente. Se puede obtener usando la función dim() dim(y) ## [1] 2 2 dim(z) ## [1] 4 2 Así una matriz se distingue de un vector ya que tiene, además de renglones, columnas. Escalar, vector y matriz Una forma mucho menos eficiente de definir una matriz es declarando una matriz sin elementos y después llenándolos de forma explícita y &lt;- matrix(nrow=2,ncol=2) y[1,1] &lt;- &quot;Esta&quot; y[2,1] &lt;- &quot;es&quot; y[1,2] &lt;- &quot;una&quot; y[2,2] &lt;- &quot;matriz&quot; y ## [,1] [,2] ## [1,] &quot;Esta&quot; &quot;una&quot; ## [2,] &quot;es&quot; &quot;matriz&quot; 4.3 Operaciones con matrices 4.3.1 Multiplicación de un escalar con una matriz 3*m ## [,1] [,2] [,3] ## [1,] 3 6 9 ## [2,] 12 15 18 4.3.2 Suma de dos matrices m + m ## [,1] [,2] [,3] ## [1,] 2 4 6 ## [2,] 8 10 12 n&lt;-matrix(c(2,3,4,5,6,7),ncol=3) m+n ## [,1] [,2] [,3] ## [1,] 3 6 9 ## [2,] 7 10 13 Para sumar matrices deben tener las mismas dimensiones dim(n) ## [1] 2 3 dim(m) ## [1] 2 3 (dim(n)-dim(m))==0 ## [1] TRUE TRUE 4.3.3 Multiplicación de matrices Se utiliza el operador %*%. Sí. Son tres caracteres. E incluyen dos %. No hay espacios y es un sólo operador . n&lt;-matrix(c(2,3,4,5,6,7),ncol=2) n ## [,1] [,2] ## [1,] 2 5 ## [2,] 3 6 ## [3,] 4 7 m %*% n ## [,1] [,2] ## [1,] 20 38 ## [2,] 47 92 ¿Recuerdas cuál es el criterio para calcular el producto de matrices? ¿Recuerdas cómo se multiplican dos matrices? 4.4 Seleccionar elementos de matrices Para seleccionar elementos de matrices se hace de forma análoga a vectores, es decir, se utiliza el operador []. Sólo que esta vez hay que indicar tanto los renglones como la columna en ese orden m[2,3] # Este es el segundo renglón tercera columna de m ## [1] 6 n[3,2] # Este es el elemento que está en el renglón 3 y columna 2 de la matriz n ## [1] 7 4.4.1 Seleccionar todo(a) un(a) renglón(columna) Para seleccionar todos los elementos de un renglón dado se utiliza la siguiente sintáxis m[2,] # Todos los elementos que están en el segundo renglón ## [1] 4 5 6 Para una columna m[,3] # Toda la tercera columna ## [1] 3 6 4.4.2 Selecccionar elementos de una matriz ¿Qué hace lo siguiente? m[1:2,1] ## [1] 1 4 m[1:2,2:3] ## [,1] [,2] ## [1,] 2 3 ## [2,] 5 6 m[-1,] ## [1] 4 5 6 m[-1,-c(1,3)] ## [1] 5 4.5 Nombres a renglones y columnas Al igual que con vectores le podemos poner nombres tanto a renglones como a columnas para ello utilizamos rownames() y colnames() m # No tengo nombres :( ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 colnames(m)&lt;-LETTERS[1:3] rownames(m)&lt;-letters[5:6] m # Ahora sí. Feos, pero nombres :) :) ## A B C ## e 1 2 3 ## f 4 5 6 m[&quot;e&quot;,&quot;C&quot;] ## [1] 3 m[&quot;e&quot;,&quot;C&quot;]==m[1,3] ## [1] TRUE "],["Estructuras_de_seleccion.html", "Chapter 5 Estructuras de selección 5.1 If (si condicional) 5.2 Combinación de operadores booleanos 5.3 Ejercicio 5.4 If … else (si … de otro modo) 5.5 ifelse 5.6 If … else if … else ( si, si no si , si no si, si no) 5.7 Ejercicios", " Chapter 5 Estructuras de selección if if … else ifelse if ... else if ...else if ...else 5.1 If (si condicional) La instrucción if nos permite probar una condición y esa condición debe arrojar un valor booleano, es decir, un valor de verdad (TRUE o FALSE) Si la condición es verdadera se ejecuta lo que está dentro de los corchetes, de lo contrario, ejecuta lo que sigue después del corchete de cierre. Definición: Lo que se encuentra dentra del corchete se llama cuerpo ( body ) de la declaración if Diagrama de flujo del If La sintáxis de una condición if consiste en lo siguiente: if (condicion){ si la condicion es verdadera Ejecuta TODO lo que está en los corchetes } 5.1.1 Sintaxis if(&lt;condition&gt;) { ## Hace algo } ## Continúa con el resto del código 5.1.2 Errores comunes en el if No incializar la variable de la condición. La condición no arroja un valor de verdad. No poner todo lo que quieres que haga dentro de los corchetes. Este no es un error, es más bien una advertencia, si la condición arroja un sólo valor de verdad sólo toma en cuenta el primero de ellos. ###Ejemplos de uso del if mayor_de_edad&lt;-18 edad&lt;-20 if(edad &gt;=mayor_de_edad){ print(&quot;Eres mayor de edad&quot;) } ## [1] &quot;Eres mayor de edad&quot; x&lt;-5+4 print(x) ## [1] 9 minimo&lt;-20000 dinero&lt;-15000 if(dinero&gt;=minimo){ print(&quot;¿Cómo está Cancún?&quot;) print(&quot;La vida es buena&quot;) sobrante&lt;-dinero-minimo print(paste(&quot;Me queda $&quot;, sobrante)) } print(&quot;Acá sigue&quot;) ## [1] &quot;Acá sigue&quot; 5.1.2.1 Ejercicios Elabora un programa que compare tu estatura con tu ídolx y determine si eres más altx. Toma dos archivos fasta de virus distintos. Leelos con Biostrings y compara sus tamaños ( en bp) y determina si el primero es más grande que el segundo. A partir del archivo de anotación del genoma de un organismo determina toma dos proteínas al azar y compara sus tamaños. Toma todos los genes de la cadena positiva y todos los de la negativa compara sus tamaños promedio y determina cuál de estos es más grande. 5.2 Combinación de operadores booleanos Los operadores lógicos o booleanos se pueden combinar para formar enunciados complejos por ejemplo: Tengo vacaciones (del trabajo y/o la escuela) Tengo dinero Si las dos condiciones son ciertas entonces puedo hacer algo También podría ser que basta con que una de ellas sea cierta para que haga algo. 5.2.1 And (&amp;) El operador booleano &amp; representa el y lógico. Estos operadores binarios nos sirven para unir al menos dos enunciados que tienen valor de verdadero o falso (Tengo dinero (V/F), Tengo vacaciones (V/F)) Con estas dos operaciones puedo unirlas utilizando el operador y lógico (AND (&amp;) representado en R con el símbolo del ampersand (&amp;) Tengo dinero AND Tengo vaciones Para saber el valor booleano (V/F) del enunciado anterior debemos concocer los valores de verdad de los enunciados por separado Por ejemplo, podemos representar al primer enunciado por p y al segundo enunciado por q p: Tengo dinero q: Tengo vacaciones Para saber cuál es el valor de verdad del enunciado compuesto debemos ver cuáles son todas las combinaciones de valores de verdad de los enunciados que la componen: p verdadero y q verdadero, p falso y q verdadero, p falso y q verdadero, p falso y q falso. Eso se resumen en las tablas de verdad de los operadores Tabla de verdad del AND p q p &amp; q V V V V F F F V F F F F Es decir, el &amp; solo es verdadero cuando ambas condciones son verdaderas. Esto representa lo que se observa en la realidad: es decir, solo hago algo si tengo y tengo vacaciones. Si una de ellas no se cumple (es decir, es falsa) entonces no se lleva a cabo la acción. 5.2.2 OR (|) El operador booleano | representa el o lógico. Estos operadores binarios nos sirven para unir al menos dos enunciados que tienen valor de verdadero o falso (Tengo dinero (V/F), Tengo vacaciones (V/F)) Con estas dos operaciones puedo unirlas utilizando el operador y lógico (OR (|) representado en R con el símbolo de la barrita (|) Tengo dinero OR Tengo vaciones Para saber el valor booleano (V/F) del enunciado anterior debemos concocer los valores de verdad de los enunciados por separado Por ejmplo podemos representar al primer enunciado por p y al segundo enunciado por q p: Tengo dinero q: Tengo vacaciones Para saber cuál es el valor de verdad del enunciado compuesto debemos ver cuáles son todas las combinaciones de valores de verdad de los enunciados que la componen: p verdadero y q verdadero, p falso y q verdadero, p falso y q verdadero, p falso y q falso. Eso se resumen en las tablas de verdad de los operadores Tabla de verdad del operador OR p q p | q V V V V F V F V V F F F Es decir haría algo, por ejemplo, irme a la playa cuando al menos una condición se cumpla. Por ejemplo que tenga dinero aunque no tenga vacaciones, que tenga vacaciones aunque no tenga dinero y, obviamente, también cuando las dos se cumplen. Es decir, el | solo es falso cuando ambas condiciones son falsas. 5.2.3 Ejemplos de combinaciones Por eejmplo es útil para intervalos \\[ 18 \\leq edad \\leq 29 \\] Esta condición la podemos expresar mediante la combinación de dos: la edad debe ser mayor igual a 18 y (AND, &amp;) la edad debe ser menor o igual que 29 if (edad &gt;= 18 &amp; edad &lt;=29){ print(&quot;Te toca vacunarte&quot;) } ## [1] &quot;Te toca vacunarte&quot; Pregunta: ¿qué pasaría si se pone un OR como unión entre las dos condiciones if (edad &gt;= 18 | edad &lt;=29){ print(&quot;Te toca vacunarte&quot;) } ## [1] &quot;Te toca vacunarte&quot; o así (¿es lo mismo?) if (edad &lt;= 29 | edad &gt;= 18){ print(&quot;Te toca vacunarte&quot;) } ## [1] &quot;Te toca vacunarte&quot; 5.3 Ejercicio ¿Cómo harías una condición que considere que te gusta el mole y el pozole? ¿Cómo harías una condición que considere que te gusta el mole o el pozole? 5.4 If … else (si … de otro modo) Si además quieres que se ejecute algo cuando la condición es falsa entonces debes usar la declaración if … else if (condición) { # Si la condición es cierta hace esto y esto y esto } else { # De otro modo, es decir si es falsa hace lo que #está en el corchete entonces hace esto otro y esto otro y esto } Diagrama_if_else minimo&lt;-20000 vacaciones&lt;-&quot;SI&quot; dinero&lt;-21000 if(dinero&gt;=minimo &amp; vacaciones==&quot;SI&quot;){ print(&quot;Me voy a la playa, looser&quot;) }else{ print(&quot;Me quedo en mi casa&quot;) } ## [1] &quot;Me voy a la playa, looser&quot; 5.5 ifelse Si la condición es muy simple ,tanto para cuando es verdadero como cuando es falso se puede implementar la función ifelse en una línea. Es equivalente a la condición compuesta pero ahorramos código. edad&lt;-21 ifelse(edad&gt;=18, &quot;Ya eres grande&quot;,&quot;Todavia no puedes beber (legalmente)&quot;) ## [1] &quot;Ya eres grande&quot; edad&lt;-12 ifelse(edad&gt;=18, &quot;Ya eres grande&quot;,&quot;Todavia no puedes beber (legalmente)&quot;) ## [1] &quot;Todavia no puedes beber (legalmente)&quot; 5.6 If … else if … else ( si, si no si , si no si, si no) Si tienes más opciones, es decir no alternativas, puedes usar la sentencia if … else if …else if …else Importante Esta estructura se ejecuta solo en la primera que sea verdadera o si no hay una verdadera ejecuta lo que esta en el else if ( condicion 1) { Hace cosas } else if ( condcion 2) { Hace otras cosas } else if ( condicion 3) { Hace estas otras cosas } else { No le queda de otra y hace esto } Diagrama de flujo del if… else if… else if…else numero&lt;-3 if(numero &gt; 0){ print(&quot;Tu número es positivo&quot;) }else if (numero &lt;0){ print(&quot;Tu número es negativo&quot;) }else{ print(&quot;Tu número es cero&quot;) } ## [1] &quot;Tu número es positivo&quot; numero&lt;- -27 if(numero &gt; 0){ print(&quot;Tu número es positivo&quot;) }else if (numero &lt;0){ print(&quot;Tu número es negativo&quot;) }else{ print(&quot;Tu número es cero&quot;) } ## [1] &quot;Tu número es negativo&quot; numero&lt;- 0 if(numero &gt; 0){ print(&quot;Tu número es positivo&quot;) }else if (numero &lt;0){ print(&quot;Tu número es negativo&quot;) }else{ print(&quot;Tu número es cero&quot;) } ## [1] &quot;Tu número es cero&quot; Pregunta: ¿por qué no es necesario poner un if en el último else? 5.7 Ejercicios Elabora un programa que con tu fecha de cumpleaños te diga en qué estación del año naciste. Elabora un porgrama que a partir de las calficaciones de tus examenes parciales y 8 quincenales arroje si exentaras o no este curso usando los criterios definidos en el programa del curso. Asume que en las tareas y demás actividades tienes 10. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
